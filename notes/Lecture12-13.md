# Lecture12

## Paper: Atomicity

并发一致的要求一般有两种：顺序一致或原子性

顺序一致：可以通过显式的编程保证：比如“读取键盘的输入”一定发生在“键盘输入显示在屏幕”之前

### Before-or-After Atomicity

并发行为具有原子性是指：从其调用者的角度，该行为要么还没发生，要么已经发生，不存在中间状态。

优势：在不知道并发行为的发生顺序时使用。

没有确保原子性的典型错误例子：（注意写入操作通常有两部，读取数据 ---> 数据写入）

### 正确性和序列化

如何定义并发行为是正确的？等价于可序列化操作

>计算机系统对并发[事务](https://baike.baidu.com/item/事务/5945882)中并发操作的调度是随机的，而不同的调度可能会产生不同的结果。在计算机中，多个事务的[并发](https://baike.baidu.com/item/并发/11024806)执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种[调度](https://baike.baidu.com/item/调度/206795)策略为可串行化（Serializable）调度。

什么是可序列化：一定顺序的并发事务发生后，产生了相同的结果，上图中的RWRW就是可以序列化并发事务。而RRWW就不是。

有时候需要比可序列化更强的正确性定义：必须必须保证事务T1发生在事务T2之前。

### 简单锁和两段锁

简单锁（一次性锁）是指transaction开始前，把**一次性把所有**可能要读写的数据都获得锁，再进行操作，commit或者roll back之后，释放锁。

两段锁把事务内部的锁分为两端，生长阶段（加锁阶段）和衰减阶段（解锁阶段），两阶段不能重合。一般加锁阶段在transaction开始执行时，解锁阶段在comit或者roll back之后。

分为S锁（共享锁）和X锁（排他锁），对只读数据加S锁，允许其他事务读，对要写数据加X锁，不允许其他事务读写。（生长阶段可以对锁升级）

### 分布式事务原子性： Two-Phase Commit（2PC）

背景：在分布式系统中，如果一项事务需要保证其原子性，如何实现？

2PC协议：保证分布式系统事务的原子性，分为事务协调者（TC）和事务管理器（TM，在单机上实现分布式事务的一部分）。分为两个阶段prepare和commit

Prepare阶段：TC写本地日志（WAL）并持久化，发送prepare给各个TM，TM写日志并持久化，决定提交发送Ready T，不准备提交发送abort T。

Commit阶段：TC发现所有TM都是ready状态，则写持久化日志，并发送commit命令，如果有一个TM时abort，则向所有TM发送abort命令。

几个要注意的点：

* TM（参与者）在发送Ready T之前，可以自由决定是否执行transaction，但是一旦发送，该transaction执行与否则完全交由TC决定。为了保证参与者一定能够执行这个承诺，需要WAL。
* 2PC一共需要发送3N次RPC请求
* 优化思路：协调者不再持久化日志，而是让参与者持久化参与者名单及事务状态，从而降低持久化时间。另一个优化思路是，当所有TM都prepare后，TC直接返回成功，但可能增加读的等待时间（等待第二阶段的提交）
* 异常处理：
  * TM宕机，在发送ready前宕机，TC当作其abort，发送后宕机，忽略它是否宕机.
  * TM在事务执行时宕机,如果没有WAl,则放弃,如果有WAL,则需要向TC或者其他TM询问此次事务是否是commit,此时如果TC和其他TM无法联系,永久询问(不理想情况)
  * TC宕机,如果有一个TW中的该事务是已经commit,其他TW也会commit,有一个TW是abort,则其他事务也abort,如果全部TW的该事务都是ready,则只能等TC恢复(不理想情况,因为此时TW无法知道该事务的状态）